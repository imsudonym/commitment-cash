pragma cashscript 0.11.0;

contract SoloCommitment(
    bytes20 ownerPkh,
    bytes20 arbiterPkh,
    int expiration, 
    int claimAmount) {

    function release(
        pubkey arbiterPk,
        sig arbiterSig,
        int dynamicFee) {

        require(
            hash160(arbiterPk) == arbiterPkh, 
            'Caller must be owner or arbiter'
        );

        require(checkSig(arbiterSig, arbiterPk), 'Invalid signature');
        require(tx.locktime < expiration, 'Commitment has expired');
        require(tx.outputs.length <= 2, 'Cannot have more than 2 outputs');
        
        int minerFee = dynamicFee;
        int currentValue = tx.inputs[this.activeInputIndex].value;
        int releaseAmount = claimAmount; //+ minerFee;
        int changeAmount = currentValue - (releaseAmount + minerFee);

        // change is less than released (the change cannot be released next time as 
        // it cannot cover the release amount + fee)
        if (changeAmount < releaseAmount) {
            // add the changeAmount to the releaseAmount
            releaseAmount = releaseAmount + changeAmount;
        } else {
            // change must be sent back to contract
            bytes changeBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;
            require(tx.outputs[1].lockingBytecode == changeBytecode, 'Change must be sent back to contract');
            require(tx.outputs[1].value == changeAmount, 'Incorrect changeValue');
        }

        bytes25 ownerLock = new LockingBytecodeP2PKH(ownerPkh);
        bool sendsToOwner = tx.outputs[0].lockingBytecode == ownerLock;
        require(tx.outputs[0].value == releaseAmount, 'Incorrect release amount');
        require(sendsToOwner, 'Rewards can only be sent to owner');
    }

    function cancel(pubkey pk, sig s, int dynamicFee) {
        require(
            hash160(pk) == ownerPkh || hash160(pk) == arbiterPkh, 
            'Caller must be owner or arbiter'
        );
        require(checkSig(s, pk), 'Invalid signature');
        require(tx.locktime < expiration, 'Cannot cancel an expired commitment');
        require(tx.outputs.length <= 2, 'Cannot have more than 2 outputs');

        int minerFee = dynamicFee;
        int currentValue = tx.inputs[this.activeInputIndex].value - minerFee;
        int refundAmount = (currentValue * 70) / 100; // only 70% of balance is refunded
        int sweepAmount = currentValue - refundAmount;

        require(tx.outputs[0].value == refundAmount, 'Incorrect refundAmount, this value must only be 70% of balance');
        require(tx.outputs[1].value == sweepAmount, 'Incorrect sweepAmount, this value must only be 30% of balance');

        bytes25 ownerLock = new LockingBytecodeP2PKH(ownerPkh);
        bytes25 arbiterLock = new LockingBytecodeP2PKH(arbiterPkh);
        bool sendsToOwner = tx.outputs[0].lockingBytecode == ownerLock;
        bool sendsToArbiter = tx.outputs[1].lockingBytecode == arbiterLock;

        require(sendsToOwner, 'Refund must send to owner');
        require(sendsToArbiter, 'Sweep must send to arbiter');
    }

    function sweep(pubkey pk, sig s) {
        require(hash160(pk) == arbiterPkh, 'Caller must be arbiter');
        require(checkSig(s, pk), 'Invalid signature');
        require(tx.locktime >= expiration, 'Commitment not expired');
    }
}